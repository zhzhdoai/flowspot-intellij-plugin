/*
 * Copyright 2024 FlowSpot plugin contributors
 *
 * This file is part of IntelliJ FlowSpot plugin.
 *
 * IntelliJ FlowSpot plugin is free software: you can redistribute it 
 * and/or modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation, either version 3 of 
 * the License, or (at your option) any later version.
 *
 * IntelliJ FlowSpot plugin is distributed in the hope that it will
 * be useful, but WITHOUT ANY WARRANTY; without even the implied 
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with IntelliJ FlowSpot plugin.
 * If not, see <http://www.gnu.org/licenses/>.
 */
package com.flowspot.intellij.gui;

import com.intellij.openapi.project.Project;
import com.intellij.ui.ColoredTreeCellRenderer;
import com.intellij.ui.SimpleTextAttributes;
import com.intellij.ui.treeStructure.Tree;
import com.flowspot.intellij.model.FlowSpotVulnerability;
import com.flowspot.intellij.model.FlowSpotVulnerabilityCollection;
import com.flowspot.intellij.model.FlowSpotLocation;
import com.flowspot.intellij.model.FlowSpotFilterRule;
import com.flowspot.intellij.service.FlowSpotNavigationService;
import com.flowspot.intellij.service.FlowSpotFilterManager;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;
import javax.swing.event.TreeSelectionListener;
import javax.swing.event.TreeSelectionEvent;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.ArrayList;
import java.util.logging.Logger;

/**
 * FlowSpot 漏洞树面板
 * 以树形结构展示漏洞分析结果
 */
public class FlowSpotVulnerabilityTreePanel extends JPanel {
    
    private static final Logger logger = Logger.getLogger(FlowSpotVulnerabilityTreePanel.class.getName());
    
    private final Project project;
    private final Tree vulnerabilityTree;
    private final DefaultTreeModel treeModel;
    private final DefaultMutableTreeNode rootNode;
    private final FlowSpotNavigationService navigationService;
    private final FlowSpotFilterManager filterManager;
    // 原始的完整漏洞集合（未过滤）
    private FlowSpotVulnerabilityCollection originalVulnerabilityCollection;
    // 当前显示的漏洞集合（可能已过滤）
    private FlowSpotVulnerabilityCollection currentCollection;
    private final List<VulnerabilitySelectionListener> selectionListeners = new ArrayList<>();
    
    /**
     * 漏洞选择监听器接口
     */
    public interface VulnerabilitySelectionListener {
        void onVulnerabilitySelected(@Nullable FlowSpotVulnerability vulnerability);
    }
    
    
    public FlowSpotVulnerabilityTreePanel(@NotNull Project project) {
        this.project = project;
        this.navigationService = new FlowSpotNavigationService(project);
        this.filterManager = FlowSpotFilterManager.getInstance(project);
        
        // 创建根节点和树模型
        rootNode = new DefaultMutableTreeNode("FlowSpot Analysis Results");
        treeModel = new DefaultTreeModel(rootNode);
        
        // 创建树组件
        vulnerabilityTree = new Tree(treeModel);
        vulnerabilityTree.setRootVisible(true);
        vulnerabilityTree.setShowsRootHandles(true);
        vulnerabilityTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        
        // 设置自定义渲染器
        vulnerabilityTree.setCellRenderer(new FlowSpotTreeCellRenderer());
        
        initializeUI();
        setupEventHandlers();
    }
    
    /**
     * 初始化UI组件
     */
    private void initializeUI() {
        setLayout(new BorderLayout());
        
        // 创建工具栏
        JToolBar toolBar = new JToolBar();
        toolBar.setFloatable(false);
        
        
        // 展开/折叠按钮 - 暂时注释
        /*
        JButton expandAllButton = new JButton("Expand All");
        expandAllButton.addActionListener(e -> expandAll());
        toolBar.add(expandAllButton);
        
        JButton collapseAllButton = new JButton("Collapse All");
        collapseAllButton.addActionListener(e -> collapseAll());
        toolBar.add(collapseAllButton);
        */
        
        add(toolBar, BorderLayout.NORTH);
        
        // 创建树的滚动面板
        JScrollPane scrollPane = new JScrollPane(vulnerabilityTree);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        add(scrollPane, BorderLayout.CENTER);
        
        // 创建状态栏
        JLabel statusLabel = new JLabel("No vulnerabilities to display");
        statusLabel.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));
        add(statusLabel, BorderLayout.SOUTH);
    }
    
    /**
     * 设置事件处理器
     */
    private void setupEventHandlers() {
        // 树选择监听器
        vulnerabilityTree.addTreeSelectionListener(new TreeSelectionListener() {
            @Override
            public void valueChanged(TreeSelectionEvent e) {
                FlowSpotVulnerability selectedVulnerability = getSelectedVulnerability();
                fireVulnerabilitySelected(selectedVulnerability);
            }
        });
        
        // 双击导航到源代码
        vulnerabilityTree.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 1) {
                    TreePath path = vulnerabilityTree.getPathForLocation(e.getX(), e.getY());
                    if (path != null) {
                        DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
                        if (node.getUserObject() instanceof FlowSpotTreeNodeData) {
                            FlowSpotTreeNodeData nodeData = (FlowSpotTreeNodeData) node.getUserObject();
                            if (nodeData.getVulnerability() != null) {
                                navigateToVulnerability(nodeData.getVulnerability());
                            }
                        }
                    }
                }
            }
        });
        
        // 右键菜单
        vulnerabilityTree.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showContextMenu(e);
                }
            }
            
            @Override
            public void mouseReleased(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showContextMenu(e);
                }
            }
        });
    }
    
    /**
     * 显示右键菜单
     */
    private void showContextMenu(MouseEvent e) {
        TreePath path = vulnerabilityTree.getPathForLocation(e.getX(), e.getY());
        if (path != null) {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
            if (node.getUserObject() instanceof FlowSpotTreeNodeData) {
                FlowSpotTreeNodeData nodeData = (FlowSpotTreeNodeData) node.getUserObject();
                if (nodeData.getVulnerability() != null) {
                    JPopupMenu popup = createContextMenu(nodeData.getVulnerability());
                    popup.show(vulnerabilityTree, e.getX(), e.getY());
                }
            }
        }
    }
    
    /**
     * 创建右键菜单
     */
    private JPopupMenu createContextMenu(FlowSpotVulnerability vulnerability) {
        JPopupMenu popup = new JPopupMenu();
        
        JMenuItem navigateItem = new JMenuItem("Navigate to Source");
        navigateItem.addActionListener(e -> navigateToVulnerability(vulnerability));
        popup.add(navigateItem);
        
        JMenuItem copyItem = new JMenuItem("Copy Info");
        copyItem.addActionListener(e -> copyVulnerabilityInfo(vulnerability));
        popup.add(copyItem);
        
        popup.addSeparator();
        
        // 过滤菜单
        JMenu filterMenu = new JMenu("Filter Data Flow");
        
        // 为每个数据流位置创建过滤选项
        List<FlowSpotLocation> locations = vulnerability.getLocations();
        if (locations != null && !locations.isEmpty()) {
            for (int i = 0; i < locations.size(); i++) {
                FlowSpotLocation location = locations.get(i);
                if (location.getClassName() != null && location.getMethodName() != null) {
                    String displayText = String.format("Step %d: %s.%s", 
                        i + 1, 
                        getSimpleClassName(location.getClassName()), 
                        location.getMethodName());
                    
                    JMenuItem filterItem = new JMenuItem(displayText);
                    filterItem.addActionListener(e -> showFilterOptionsDialog(location));
                    filterMenu.add(filterItem);
                }
            }
        }
        
        if (filterMenu.getItemCount() > 0) {
            popup.add(filterMenu);
        }
        
        // 管理过滤规则
        popup.addSeparator();
        JMenuItem manageFiltersItem = new JMenuItem("Manage Filter Rules...");
        manageFiltersItem.addActionListener(e -> showFilterManagementDialog());
        popup.add(manageFiltersItem);
        
        return popup;
    }
    
    /**
     * 获取简单类名（去掉包名）
     */
    private String getSimpleClassName(String fullClassName) {
        if (fullClassName == null) return "Unknown";
        int lastDot = fullClassName.lastIndexOf('.');
        return lastDot >= 0 ? fullClassName.substring(lastDot + 1) : fullClassName;
    }
    
    /**
     * 显示过滤选项对话框
     */
    private void showFilterOptionsDialog(FlowSpotLocation location) {
        String[] options = {
            "Filter Exact Match (" + getSimpleClassName(location.getClassName()) + "." + location.getMethodName() + ")",
            "Filter Class (" + getSimpleClassName(location.getClassName()) + ".*)",
            "Filter Method (*." + location.getMethodName() + ")",
            "Cancel"
        };
        
        int choice = JOptionPane.showOptionDialog(
            this,
            "Choose filter type for data flow node:\n" + 
            "Class: " + location.getClassName() + "\n" +
            "Method: " + location.getMethodName(),
            "Add Filter Rule",
            JOptionPane.YES_NO_CANCEL_OPTION,
            JOptionPane.QUESTION_MESSAGE,
            null,
            options,
            options[0]
        );
        
        FlowSpotFilterRule rule = null;
        switch (choice) {
            case 0: // Exact match
                rule = filterManager.createExactMatchRule(
                    location.getClassName(), 
                    location.getMethodName(),
                    "Filter exact match: " + getSimpleClassName(location.getClassName()) + "." + location.getMethodName()
                );
                break;
            case 1: // Class match
                rule = filterManager.createClassMatchRule(
                    location.getClassName(),
                    "Filter class: " + getSimpleClassName(location.getClassName())
                );
                break;
            case 2: // Method match
                rule = filterManager.createMethodMatchRule(
                    location.getMethodName(),
                    "Filter method: " + location.getMethodName()
                );
                break;
            default:
                return; // Cancel
        }
        
        if (rule != null) {
            filterManager.addFilterRule(rule);
            
            // 显示确认消息
            JOptionPane.showMessageDialog(
                this,
                "Filter rule added successfully!\n" +
                "Rule: " + rule.getDisplayName() + "\n" +
                "This rule will be applied to future analysis results.",
                "Filter Rule Added",
                JOptionPane.INFORMATION_MESSAGE
            );
            
            // 可选：立即重新应用过滤规则到当前结果
            if (originalVulnerabilityCollection != null) {
                refreshWithCurrentFilters();
            }
        }
    }
    
    /**
     * 显示过滤规则管理对话框
     */
    private void showFilterManagementDialog() {
        FlowSpotFilterManagementDialog dialog = new FlowSpotFilterManagementDialog(project, filterManager);
        dialog.setVisible(true);
        
        // 如果规则有变化，刷新显示
        if (dialog.isRulesChanged() && originalVulnerabilityCollection != null) {
            refreshWithCurrentFilters();
        }
    }
    
    /**
     * 使用当前过滤规则刷新显示
     */
    public void refreshWithCurrentFilters() {
        System.out.println("FlowSpotVulnerabilityTreePanel: refreshWithCurrentFilters 被调用");
        if (originalVulnerabilityCollection != null) {
            System.out.println("FlowSpotVulnerabilityTreePanel: 原始漏洞数量: " + originalVulnerabilityCollection.getVulnerabilities().size());
            FlowSpotVulnerabilityCollection filteredCollection = filterManager.applyFilters(originalVulnerabilityCollection);
            System.out.println("FlowSpotVulnerabilityTreePanel: 过滤后漏洞数量: " + filteredCollection.getVulnerabilities().size());
            // 只更新当前显示的集合，不修改原始集合
            this.currentCollection = filteredCollection;
            refreshTree();
            System.out.println("FlowSpotVulnerabilityTreePanel: 漏洞树刷新完成");
        } else {
            System.out.println("FlowSpotVulnerabilityTreePanel: originalVulnerabilityCollection 为空，无法刷新");
        }
    }
    
    /**
     * 更新漏洞显示
     */
    public void updateVulnerabilities(@NotNull FlowSpotVulnerabilityCollection collection) {
        // 保存原始的完整集合
        this.originalVulnerabilityCollection = collection;
        this.currentCollection = collection;
        
        // 刷新树显示
        refreshTree();
    }
    
    /**
     * 导航到漏洞源代码
     */
    private void navigateToVulnerability(FlowSpotVulnerability vulnerability) {
        FlowSpotLocation location = vulnerability.getPrimaryLocation();
        if (location != null) {
            boolean success = navigationService.navigateToLocation(location);
            if (!success) {
                // 显示导航失败的通知
                JOptionPane.showMessageDialog(this, 
                    "Could not navigate to: " + location.getDisplayText(),
                    "Navigation Failed", 
                    JOptionPane.WARNING_MESSAGE);
            }
        }
    }
    
    /**
     * 复制漏洞信息到剪贴板
     */
    private void copyVulnerabilityInfo(FlowSpotVulnerability vulnerability) {
        StringBuilder sb = new StringBuilder();
        sb.append("FlowSpot Vulnerability Information\n");
        sb.append("=================================\n\n");
        sb.append("Type: ").append(vulnerability.getType()).append("\n");
        sb.append("Category: ").append(vulnerability.getCategory()).append("\n");
        sb.append("Severity: ").append(vulnerability.getSeverity()).append("\n");
        sb.append("Title: ").append(vulnerability.getTitle()).append("\n\n");
        sb.append("Description:\n").append(vulnerability.getDescription()).append("\n\n");
        
        if (vulnerability.getPrimaryLocation() != null) {
            sb.append("Location: ").append(vulnerability.getPrimaryLocation().getDisplayText()).append("\n");
        }
        
        // 复制到剪贴板
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(
            new java.awt.datatransfer.StringSelection(sb.toString()), null);
        
        // 显示复制成功的通知
        JOptionPane.showMessageDialog(this, 
            "Vulnerability information copied to clipboard",
            "Copy Successful", 
            JOptionPane.INFORMATION_MESSAGE);
    }
    
    /**
     * 设置漏洞集合并刷新树
     */
    public void setVulnerabilityCollection(@Nullable FlowSpotVulnerabilityCollection collection) {
        this.currentCollection = collection;
        refreshTree();
    }
    
    /**
     * 刷新树显示
     */
    private void refreshTree() {
        rootNode.removeAllChildren();
        
        if (currentCollection == null || currentCollection.isEmpty()) {
            rootNode.setUserObject("No vulnerabilities found");
            treeModel.reload();
            return;
        }
        
        rootNode.setUserObject("FlowSpot Results (" + currentCollection.getTotalCount() + " vulnerabilities)");
        
        // 固定使用按分类排序
        buildTreeByCategory();
        
        treeModel.reload();
        // 默认折叠所有节点，保持简洁的显示
        collapseAll();
        System.out.println("FlowSpotVulnerabilityTreePanel: 树刷新完成，默认折叠所有节点");
    }
    
    /**
     * 按分类构建树
     */
    private void buildTreeByCategory() {
        Set<String> allCategories = currentCollection.getAllCategories();
        logger.info("FlowSpotVulnerabilityTreePanel: Building tree with categories: " + allCategories);
        
        for (String category : allCategories) {
            List<FlowSpotVulnerability> vulnerabilities = currentCollection.getVulnerabilitiesByCategory(category);
            logger.info("FlowSpotVulnerabilityTreePanel: Category '" + category + "' has " + vulnerabilities.size() + " vulnerabilities");
            
            if (!vulnerabilities.isEmpty()) {
                DefaultMutableTreeNode categoryNode = new DefaultMutableTreeNode(
                    new FlowSpotTreeNodeData(category + " (" + vulnerabilities.size() + ")", null));
                rootNode.add(categoryNode);
                
                for (FlowSpotVulnerability vulnerability : vulnerabilities) {
                    DefaultMutableTreeNode vulnNode = new DefaultMutableTreeNode(
                        new FlowSpotTreeNodeData(vulnerability.getShortDisplayText(), vulnerability));
                    categoryNode.add(vulnNode);
                }
            }
        }
    }
    
    /**
     * 按类型构建树
     */
    private void buildTreeByType() {
        Map<String, List<FlowSpotVulnerability>> byType = currentCollection.getVulnerabilitiesByType();
        for (Map.Entry<String, List<FlowSpotVulnerability>> entry : byType.entrySet()) {
            String type = entry.getKey();
            List<FlowSpotVulnerability> vulnerabilities = entry.getValue();
            
            DefaultMutableTreeNode typeNode = new DefaultMutableTreeNode(
                new FlowSpotTreeNodeData(type + " (" + vulnerabilities.size() + ")", null));
            rootNode.add(typeNode);
            
            for (FlowSpotVulnerability vulnerability : vulnerabilities) {
                DefaultMutableTreeNode vulnNode = new DefaultMutableTreeNode(
                    new FlowSpotTreeNodeData(vulnerability.getShortDisplayText(), vulnerability));
                typeNode.add(vulnNode);
            }
        }
    }
    
    /**
     * 按文件构建树
     */
    private void buildTreeByFile() {
        Map<String, List<FlowSpotVulnerability>> byFile = currentCollection.getVulnerabilitiesByFile();
        for (Map.Entry<String, List<FlowSpotVulnerability>> entry : byFile.entrySet()) {
            String file = entry.getKey();
            List<FlowSpotVulnerability> vulnerabilities = entry.getValue();
            
            DefaultMutableTreeNode fileNode = new DefaultMutableTreeNode(
                new FlowSpotTreeNodeData(file + " (" + vulnerabilities.size() + ")", null));
            rootNode.add(fileNode);
            
            for (FlowSpotVulnerability vulnerability : vulnerabilities) {
                DefaultMutableTreeNode vulnNode = new DefaultMutableTreeNode(
                    new FlowSpotTreeNodeData(vulnerability.getShortDisplayText(), vulnerability));
                fileNode.add(vulnNode);
            }
        }
    }
    
    /**
     * 按严重程度构建树
     */
    private void buildTreeBySeverity() {
        Map<String, List<FlowSpotVulnerability>> bySeverity = currentCollection.getVulnerabilitiesBySeverity();
        for (Map.Entry<String, List<FlowSpotVulnerability>> entry : bySeverity.entrySet()) {
            String severity = entry.getKey();
            List<FlowSpotVulnerability> vulnerabilities = entry.getValue();
            
            DefaultMutableTreeNode severityNode = new DefaultMutableTreeNode(
                new FlowSpotTreeNodeData(severity + " (" + vulnerabilities.size() + ")", null));
            rootNode.add(severityNode);
            
            for (FlowSpotVulnerability vulnerability : vulnerabilities) {
                DefaultMutableTreeNode vulnNode = new DefaultMutableTreeNode(
                    new FlowSpotTreeNodeData(vulnerability.getShortDisplayText(), vulnerability));
                severityNode.add(vulnNode);
            }
        }
    }
    
    /**
     * 构建平铺树
     */
    private void buildFlatTree() {
        for (FlowSpotVulnerability vulnerability : currentCollection.getAllVulnerabilities()) {
            DefaultMutableTreeNode vulnNode = new DefaultMutableTreeNode(
                new FlowSpotTreeNodeData(vulnerability.getShortDisplayText(), vulnerability));
            rootNode.add(vulnNode);
        }
    }
    
    /**
     * 展开所有节点
     */
    private void expandAll() {
        for (int i = 0; i < vulnerabilityTree.getRowCount(); i++) {
            vulnerabilityTree.expandRow(i);
        }
    }
    
    /**
     * 折叠所有节点（保持根节点展开）
     */
    private void collapseAll() {
        // 从后往前折叠，但保持根节点展开
        for (int i = vulnerabilityTree.getRowCount() - 1; i >= 1; i--) {
            vulnerabilityTree.collapseRow(i);
        }
        // 确保根节点展开
        if (vulnerabilityTree.getRowCount() > 0) {
            vulnerabilityTree.expandRow(0);
        }
    }
    
    /**
     * 获取当前选中的漏洞
     */
    @Nullable
    public FlowSpotVulnerability getSelectedVulnerability() {
        TreePath path = vulnerabilityTree.getSelectionPath();
        if (path != null) {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
            if (node.getUserObject() instanceof FlowSpotTreeNodeData) {
                FlowSpotTreeNodeData nodeData = (FlowSpotTreeNodeData) node.getUserObject();
                return nodeData.getVulnerability();
            }
        }
        return null;
    }
    
    /**
     * 添加漏洞选择监听器
     */
    public void addVulnerabilitySelectionListener(VulnerabilitySelectionListener listener) {
        selectionListeners.add(listener);
    }
    
    /**
     * 移除漏洞选择监听器
     */
    public void removeVulnerabilitySelectionListener(VulnerabilitySelectionListener listener) {
        selectionListeners.remove(listener);
    }
    
    /**
     * 触发漏洞选择事件
     */
    private void fireVulnerabilitySelected(@Nullable FlowSpotVulnerability vulnerability) {
        for (VulnerabilitySelectionListener listener : selectionListeners) {
            listener.onVulnerabilitySelected(vulnerability);
        }
    }
    
    /**
     * 树节点数据类
     */
    private static class FlowSpotTreeNodeData {
        private final String displayText;
        private final FlowSpotVulnerability vulnerability;
        
        public FlowSpotTreeNodeData(String displayText, @Nullable FlowSpotVulnerability vulnerability) {
            this.displayText = displayText;
            this.vulnerability = vulnerability;
        }
        
        public String getDisplayText() {
            return displayText;
        }
        
        @Nullable
        public FlowSpotVulnerability getVulnerability() {
            return vulnerability;
        }
        
        @Override
        public String toString() {
            return displayText;
        }
    }
    
    /**
     * 自定义树单元格渲染器
     */
    private static class FlowSpotTreeCellRenderer extends ColoredTreeCellRenderer {
        @Override
        public void customizeCellRenderer(@NotNull JTree tree, Object value, boolean selected,
                                        boolean expanded, boolean leaf, int row, boolean hasFocus) {
            
            if (value instanceof DefaultMutableTreeNode) {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
                Object userObject = node.getUserObject();
                
                if (userObject instanceof FlowSpotTreeNodeData) {
                    FlowSpotTreeNodeData nodeData = (FlowSpotTreeNodeData) userObject;
                    FlowSpotVulnerability vulnerability = nodeData.getVulnerability();
                    
                    if (vulnerability != null) {
                        // 漏洞节点 - 根据严重程度设置颜色
                        SimpleTextAttributes attributes = getAttributesForSeverity(vulnerability.getSeverity());
                        append(nodeData.getDisplayText(), attributes);
                        setToolTipText(vulnerability.getDescription());
                    } else {
                        // 分组节点
                        append(nodeData.getDisplayText(), SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);
                    }
                } else {
                    // 根节点或其他节点
                    append(userObject.toString(), SimpleTextAttributes.REGULAR_ATTRIBUTES);
                }
            }
        }
        
        private SimpleTextAttributes getAttributesForSeverity(String severity) {
            switch (severity) {
                case "High":
                    return SimpleTextAttributes.ERROR_ATTRIBUTES;
                case "Medium":
                    return new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, Color.ORANGE);
                case "Low":
                    return new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, Color.BLUE);
                default:
                    return SimpleTextAttributes.REGULAR_ATTRIBUTES;
            }
        }
    }
    
}
