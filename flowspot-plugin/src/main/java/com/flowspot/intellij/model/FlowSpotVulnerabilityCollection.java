/*
 * Copyright 2024 FlowSpot plugin contributors
 *
 * This file is part of IntelliJ FlowSpot plugin.
 *
 * IntelliJ FlowSpot plugin is free software: you can redistribute it 
 * and/or modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation, either version 3 of 
 * the License, or (at your option) any later version.
 *
 * IntelliJ FlowSpot plugin is distributed in the hope that it will
 * be useful, but WITHOUT ANY WARRANTY; without even the implied 
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with IntelliJ FlowSpot plugin.
 * If not, see <http://www.gnu.org/licenses/>.
 */
package com.flowspot.intellij.model;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * FlowSpot 漏洞结果集合
 * 管理和组织所有检测到的漏洞
 */
public class FlowSpotVulnerabilityCollection {
    
    private static final Logger logger = Logger.getLogger(FlowSpotVulnerabilityCollection.class.getName());
    
    private final String projectName;
    private final String analysisBasePath;  // 分析的基础路径
    private final long analysisTimestamp;
    private final List<FlowSpotVulnerability> vulnerabilities;
    private final Map<String, List<FlowSpotVulnerability>> vulnerabilitiesByCategory;
    private final Map<String, List<FlowSpotVulnerability>> vulnerabilitiesByType;
    private final Map<String, List<FlowSpotVulnerability>> vulnerabilitiesByFile;
    
    public FlowSpotVulnerabilityCollection(@NotNull String projectName) {
        this(projectName, null);
    }
    
    public FlowSpotVulnerabilityCollection(@NotNull String projectName, @Nullable String analysisBasePath) {
        this.projectName = projectName;
        this.analysisBasePath = analysisBasePath;
        this.analysisTimestamp = System.currentTimeMillis();
        this.vulnerabilities = new ArrayList<>();
        this.vulnerabilitiesByCategory = new HashMap<>();
        this.vulnerabilitiesByType = new HashMap<>();
        this.vulnerabilitiesByFile = new HashMap<>();
    }
    
    /**
     * 添加漏洞到集合中
     */
    public void addVulnerability(@NotNull FlowSpotVulnerability vulnerability) {
        vulnerabilities.add(vulnerability);
        
        // 调试信息：记录漏洞分类
        logger.info("FlowSpotVulnerabilityCollection: Adding vulnerability - type=" + 
                   vulnerability.getType() + ", category=" + vulnerability.getCategory());
        
        // 按分类分组
        vulnerabilitiesByCategory.computeIfAbsent(vulnerability.getCategory(), k -> new ArrayList<>())
                                 .add(vulnerability);
        
        // 按类型分组
        vulnerabilitiesByType.computeIfAbsent(vulnerability.getType(), k -> new ArrayList<>())
                            .add(vulnerability);
        
        // 按文件分组
        String fileName = vulnerability.getPrimaryLocation().getFileName();
        vulnerabilitiesByFile.computeIfAbsent(fileName, k -> new ArrayList<>())
                            .add(vulnerability);
    }
    
    /**
     * 批量添加漏洞
     */
    public void addVulnerabilities(@NotNull Collection<FlowSpotVulnerability> vulnerabilities) {
        vulnerabilities.forEach(this::addVulnerability);
    }
    
    /**
     * 清空所有漏洞
     */
    public void clear() {
        vulnerabilities.clear();
        vulnerabilitiesByCategory.clear();
        vulnerabilitiesByType.clear();
        vulnerabilitiesByFile.clear();
    }
    
    // Getters
    @NotNull
    public String getProjectName() { return projectName; }
    
    public long getAnalysisTimestamp() { return analysisTimestamp; }
    
    @NotNull
    public List<FlowSpotVulnerability> getVulnerabilities() { 
        return new ArrayList<>(vulnerabilities); 
    }
    
    @NotNull
    public Map<String, List<FlowSpotVulnerability>> getVulnerabilitiesByCategory() {
        return new HashMap<>(vulnerabilitiesByCategory);
    }
    
    @NotNull
    public Map<String, List<FlowSpotVulnerability>> getVulnerabilitiesByType() {
        return new HashMap<>(vulnerabilitiesByType);
    }
    
    @NotNull
    public Map<String, List<FlowSpotVulnerability>> getVulnerabilitiesByFile() {
        return new HashMap<>(vulnerabilitiesByFile);
    }
    
    /**
     * 获取指定分类的漏洞
     */
    @NotNull
    public List<FlowSpotVulnerability> getVulnerabilitiesByCategory(@NotNull String category) {
        return vulnerabilitiesByCategory.getOrDefault(category, new ArrayList<>());
    }
    
    /**
     * 获取指定类型的漏洞
     */
    @NotNull
    public List<FlowSpotVulnerability> getVulnerabilitiesByType(@NotNull String type) {
        return vulnerabilitiesByType.getOrDefault(type, new ArrayList<>());
    }
    
    /**
     * 获取指定文件的漏洞
     */
    @NotNull
    public List<FlowSpotVulnerability> getVulnerabilitiesByFile(@NotNull String fileName) {
        return vulnerabilitiesByFile.getOrDefault(fileName, new ArrayList<>());
    }
    
    /**
     * 根据优先级过滤漏洞
     */
    @NotNull
    public List<FlowSpotVulnerability> getVulnerabilitiesByPriority(int priority) {
        return vulnerabilities.stream()
                             .filter(v -> v.getPriority() == priority)
                             .collect(Collectors.toList());
    }
    
    /**
     * 根据严重程度过滤漏洞
     */
    @NotNull
    public List<FlowSpotVulnerability> getVulnerabilitiesBySeverity(@NotNull String severity) {
        return vulnerabilities.stream()
                             .filter(v -> v.getSeverity().equals(severity))
                             .collect(Collectors.toList());
    }
    
    /**
     * 查找指定ID的漏洞
     */
    @Nullable
    public FlowSpotVulnerability findVulnerabilityById(@NotNull String id) {
        return vulnerabilities.stream()
                             .filter(v -> v.getId().equals(id))
                             .findFirst()
                             .orElse(null);
    }
    
    /**
     * 获取漏洞总数
     */
    public int getTotalCount() {
        return vulnerabilities.size();
    }
    
    /**
     * 获取分类总数
     */
    public int getCategoryCount() {
        return vulnerabilitiesByCategory.size();
    }
    
    /**
     * 获取类型总数
     */
    public int getTypeCount() {
        return vulnerabilitiesByType.size();
    }
    
    /**
     * 获取分析基础路径
     */
    @Nullable
    public String getAnalysisBasePath() {
        return analysisBasePath;
    }
    
    /**
     * 获取受影响文件总数
     */
    public int getAffectedFileCount() {
        return vulnerabilitiesByFile.size();
    }
    
    /**
     * 获取所有分类名称
     */
    @NotNull
    public Set<String> getAllCategories() {
        return new HashSet<>(vulnerabilitiesByCategory.keySet());
    }
    
    /**
     * 获取所有类型名称
     */
    @NotNull
    public Set<String> getAllTypes() {
        return new HashSet<>(vulnerabilitiesByType.keySet());
    }
    
    /**
     * 获取所有受影响的文件名
     */
    @NotNull
    public Set<String> getAllAffectedFiles() {
        return new HashSet<>(vulnerabilitiesByFile.keySet());
    }
    
    /**
     * 按严重程度分组获取漏洞
     */
    @NotNull
    public Map<String, List<FlowSpotVulnerability>> getVulnerabilitiesBySeverity() {
        return vulnerabilities.stream()
                             .collect(Collectors.groupingBy(FlowSpotVulnerability::getSeverity));
    }
    
    /**
     * 获取所有漏洞列表
     */
    @NotNull
    public List<FlowSpotVulnerability> getAllVulnerabilities() {
        return new ArrayList<>(vulnerabilities);
    }
    
    /**
     * 检查是否为空
     */
    public boolean isEmpty() {
        return vulnerabilities.isEmpty();
    }
    
    /**
     * 获取统计信息
     */
    @NotNull
    public String getStatistics() {
        return String.format("Total: %d vulnerabilities, %d categories, %d types, %d files affected",
                           getTotalCount(), getCategoryCount(), getTypeCount(), getAffectedFileCount());
    }
    
    @Override
    public String toString() {
        return String.format("FlowSpotVulnerabilityCollection[project=%s, %s]", 
                           projectName, getStatistics());
    }
}
